import { defineComponent as b, ref as _, watch as C, openBlock as k, createElementBlock as D, renderSlot as g, createElementVNode as T } from "vue";
const A = {
  // 这个是示例值
  // status: {
  //   // PropType：声明时给一个 prop 标注更复杂的类型定义。
  //   type: String as PropType<"on" | "off">,
  //   required: true,
  //   default: "on",
  // },
  // 需要打印的内容，可以为字符串或者数组，数组将自动在后面添加换行符
  data: {
    type: [String, Array],
    default: ""
  },
  // 执行次数，如果小于1，则无限循环
  handlerNum: {
    type: Number,
    default: 1,
    validator(o) {
      if (o > 0)
        return !0;
      throw Error("handlerNum必须大于0");
    }
  },
  // 打印速度
  typeSpeed: {
    type: Number,
    default: 15
  },
  // 行打印速度
  typeSpeedLine: {
    type: Number,
    default: 100
  },
  //光标的符号
  cursorChar: {
    type: String,
    default: "_"
  },
  // 是否撤销显示，当data为数组时，data的后续值知否覆盖前一个值
  back: {
    type: Boolean,
    default: !1
  },
  // 回退速度
  backSpeed: {
    type: Number,
    default: 30
  },
  // 滚动容器class或者id
  scrollDom: {
    type: String,
    default: ""
  }
};
const B = { class: "content" }, L = ["innerHTML"], E = /* @__PURE__ */ b({
  name: "vueTyperNext",
  __name: "typer",
  props: A,
  emits: ["complete", "lineComplete"],
  setup(o, { expose: c, emit: d }) {
    const a = o, e = _("");
    let s = 1, u = "start", h;
    const n = `<span class="cursorChar">${a.cursorChar}</span>`;
    C(
      () => a.data,
      () => {
        console.log("watch"), s = a.handlerNum, y();
      },
      {
        immediate: !0
      }
    );
    function f() {
      e.value = "", e.value = e.value + n;
    }
    async function y() {
      if (Array.isArray(a.data)) {
        for (; s > 0; )
          f(), await S(), s--;
        d("complete");
      } else {
        for (; s > 0; )
          f(), await w(), s--;
        d("complete");
      }
    }
    async function w() {
      for (let t = 0; t < a.data.length; t++) {
        const l = a.data[t];
        e.value = e.value.slice(0, e.value.length - n.length) + l + (t < a.data.length - 1 ? e.value.slice(e.value.length - n.length) : ""), await i(a.typeSpeed), m();
      }
    }
    async function S() {
      for (let t = 0; t < a.data.length; t++) {
        const l = a.data[t];
        if (l)
          for (let r = 0; r < l.length; r++) {
            const p = l[r], v = e.value.length - n.length;
            e.value = e.value.slice(0, v) + p + e.value.slice(v), u === "pause" && await i(), await i(a.typeSpeed), m();
          }
        if (d("lineComplete"), await i(a.typeSpeedLine), a.back) {
          if (l && t < a.data.length - 1)
            for (let r = 0; r < l.length; r++) {
              const p = e.value.length - n.length;
              e.value = e.value.slice(0, p - 1) + e.value.slice(p), await i(a.backSpeed);
            }
        } else
          e.value = e.value.slice(0, e.value.length - n.length) + "<br/>" + (t < a.data.length - 1 ? e.value.slice(e.value.length - n.length) : "");
      }
    }
    function i(t) {
      return new Promise((l) => {
        t ? setTimeout(l, t) : h = window.setInterval(() => {
          u === "start" && (l(), clearInterval(h));
        }, 100);
      });
    }
    function m() {
      if (a.scrollDom) {
        const t = document.querySelector(a.scrollDom);
        t && (t.scrollTop = t.scrollHeight);
      }
    }
    function N() {
      u = "start";
    }
    function x() {
      u = "pause";
    }
    return c({
      start: N,
      pause: x
    }), (t, l) => (k(), D("div", B, [
      g(t.$slots, "prefix"),
      T("div", {
        class: "result",
        innerHTML: e.value
      }, null, 8, L),
      g(t.$slots, "suffix")
    ]));
  }
}), H = [E], $ = (o) => {
  H.map((c) => {
    o.component(c.name, c);
  });
};
export {
  $ as default,
  E as vueTyperNext
};
